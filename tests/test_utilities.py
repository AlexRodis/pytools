import unittest
from pytools.utilities import *
import numpy as np
import warnings
import os

class TestMatrixMeshgrid(unittest.TestCase):
    
    @classmethod
    def cleanUp(cls):
        os.remove("obj1.pickle")
        os.remove("obj2.pickle")
    
    def test_ground_truth(self):
        r'''
            Test ground truth
        '''
        
        # Example generated by ChatGPT
        x = np.linspace(0, 1, num=10)
        y = np.linspace(0, 2, num=5)
        xspan = LinearSpace(0,1,n_points=10)
        yspan = LinearSpace(0,2, n_points=5)
        xx, yy = np.meshgrid(x, y)
        ref_grid = np.vstack((np.ravel(xx), np.ravel(yy))).T
        test_grid = matrix_meshgrid(xspan,yspan)
        self.assertTrue(np.allclose(ref_grid, test_grid))
        
        
    def test_space_objects(self):
        r'''
            Test Linear Space object fields
        '''
        xspan = LinearSpace(0,1,n_points=10)
        yspan = LinearSpace(10,20, n_points=15)
        defaultspan = LinearSpace(0,1)
        self.assertTrue(all(
            [
                xspan.start == 0,
                xspan.stop == 1,
                xspan.n_points == 10,
                yspan.start == 10,
                yspan.stop == 20,
                yspan.n_points == 15,
                defaultspan.n_points == 50
            ]
        ))
        
    def test_dataframe_output(self):
        r'''
            Test DataFrame output with default columns names
        '''
        # Example generated by ChatGPT
        x = np.linspace(0, 1, num=10)
        y = np.linspace(0, 2, num=5)
        xspan = LinearSpace(0,1,n_points=10)
        yspan = LinearSpace(0,2, n_points=5)
        xx, yy = np.meshgrid(x, y)
        ref_grid = np.vstack((np.ravel(xx), np.ravel(yy))).T
        test_grid = matrix_meshgrid(
            xspan,yspan, 
            to_pandas=True)
        self.assertTrue(np.allclose(ref_grid, test_grid.values))
        
    def test_dataframe_output_columns(self):
        r'''
            Test proper output column naming
        '''
        # Example generated by ChatGPT
        x = np.linspace(0, 1, num=10)
        y = np.linspace(0, 2, num=5)
        xspan = LinearSpace(0,1,n_points=10)
        yspan = LinearSpace(0,2, n_points=5)
        xx, yy = np.meshgrid(x, y)
        ref_grid = np.vstack((np.ravel(xx), np.ravel(yy))).T
        cols:list[str] = [
                f'feature_{i}' for i in range(2)
                ]
        test_grid = matrix_meshgrid(
            xspan,yspan, 
            to_pandas=True, columns = cols
            )
        self.assertTrue(all([
            np.allclose(ref_grid, test_grid),
            [e for e in test_grid.columns] == cols,
            ])
        )
        
class TestUtilities(unittest.TestCase):

    def test_np_replace(self):
        r'''
            Test numpy_replace helper
        '''
        arr:FloatArray = np.asarray([[0,54.4],[5111.2,0]])
        strArr = np.asarray([["Hell", "o"],["Wor", "ld"]])
        nstrArr = numpy_replace(strArr, dict(Hell="Heave", ld = "any"))
        narr = numpy_replace(arr,{0:1})
        tests:list[bool] = [
            arr[0,1] == narr[0,1],
            arr[1,0] == narr[1,0],
            narr[0,0] ==1,
            narr[1,1] == 1,
            nstrArr[0,0] == "Heave",
            nstrArr[0,1] == "o",
            nstrArr[1,0] == "Wor",
            nstrArr[1,1] == "any",
        ]
        self.assertTrue(all(
            tests
        ))
        
    def test_unfold_grid(self):
        r'''
            Test unfold_grid helper function
        '''
        test_grid = dict(
            var1 = [1,2,3],
            var2 = ["Hello", "World"],
            varstatic = "this"
        )
        ref_dicts:list[dict[str,Any]] = [
            dict(var1=1, var2="Hello",
                 varstatic="this"),
            dict(var1=1, var2="World",
                 varstatic="this"),
            dict(var1=2, var2="Hello",
                 varstatic="this"),
            dict(var1=2, var2="World",
                 varstatic="this"),
            dict(var1=3, var2="Hello",
                 varstatic="this"),
            dict(var1=3, var2="World",
                 varstatic="this"),
            
        ]
        cartesian_grid = unfold_grid(test_grid)
        conds:list[bool] = [
                    d1 == d2 for d1, d2 in zip(cartesian_grid,ref_dicts,
                                               strict=True)
                ]
        with self.subTest(msg="Cartesian expansion"):
            self.assertTrue(
                all(conds) 
            )
        linear_test_grid = dict(
            var1 = [1,2,3],
            var2 = ["Hello", "World"],
            varstatic = "this"
        )
        linear_grid = unfold_grid(linear_test_grid, mode='linear')
        linear_ref  = [
            dict(
                var1 = 1, var2 ="Hello", varstatic="this"),
                dict(var1 = 2, var2 ="Hello", varstatic="this"),
                dict(var1 = 3, var2 ="Hello", varstatic="this"),
                dict(var1 = 1, var2 ="Hello", varstatic="this"),
                dict(var1 = 1, var2 ="World", varstatic="this",
            )
        ]
        with self.subTest("Linear expansion"):
            self.assertEqual(linear_ref, linear_grid)
        
        # Doctest
        grid_spec = dict(
                var1 = [1,2,3],
                var2 = ["Hello", "World"],
                var_static = "Static Value",
            )
        cartesian_grid = unfold_grid(grid_spec)
        linear_grid = unfold_grid(grid_spec, mode='linear')
        linear_grid_second_value = unfold_grid(grid_spec, 
        mode ='linear', 
        ival = 1 # Keep the second value of all other variables 
        # during linear search
        )

        
    def test_merge_dicts(self):
        one = {0:1, 2:3}
        other = {"Hi": "There", 2:"Final"}
        expected = one|other
        d = dict_merge(one, other)
        with self.subTest("Merge operator equality"):
            
            self.assertTrue(expected==d)
            
        with self.subTest("Intersecting keys warning"):
            with self.assertWarns(UserWarning):
                
                self.assertTrue(dict_merge(one, other)==expected)
                
        with self.subTest("Strict intersecting error"):
            with self.assertRaises(ValueError):
                dict_merge(one, other, strict=True)
                
        with self.subTest("Disjoint keys no warning"):
            with warnings.catch_warnings():
                warnings.simplefilter("error")
            dd = dict_merge(
                one, {"Hi":"There", "Hello":"World"}
            )
    
    def test_add_row(self):
        r'''
            Test add_row utility method
        '''
        X = np.random.rand(101,5)
        x, X = X[-1,:], X[:-1, :]
        cols = [
            f"v{i}" for i in range(X.shape[-1])
        ]
        df = pd.DataFrame(X, columns=cols)
        row = {col:x[i] for i,col in enumerate(cols)}
        ndf = add_row(df, row)
        with self.subTest("Increase shape"):
            self.assertEqual(ndf.shape[0], df.shape[0]+1)
        with self.subTest("Value"):
            self.assert_(np.allclose(
                ndf.iloc[-1,:].values, 
                pd.DataFrame(row, index=[0]).values
                ))
            
    def test_save__load(self):
        r'''
            Tests the save and load methods with cloudpickle
        '''
        obj1 = [1,2,3]
        obj2 = np.random.rand(101,5)
        save(obj1, "obj1.pickle")
        save(obj2, "obj2.pickle")
        obj3 = load("obj1.pickle")
        obj4 = load("obj2.pickle")
        with self.subTest("First object"):
            self.assertEqual(obj1, obj3)
        with self.subTest("Second object"):
            self.assertTrue(np.allclose(obj2,obj4))
    
    @unittest.skip("Testing proving difficult. Skip for now") 
    def test_value_counts(self):
        r'''
            Test get value counts, row wise
        '''
        from itertools import chain, repeat, compress
        X = np.asarray([
            [1, 0, 3, 3, 2],
            [0, 4, 2, 4, 4],
            [1, 3, 3, 1, 0],
            [4, 1, 2, 1, 2],
            [3, 4, 3, 3, 4],
            [4, 2, 3, 1, 4],
            [4, 1, 0, 3, 4],
                ])
        cols = [f"v{i}" for i in range(X.shape[-1])]
        df = pd.DataFrame(X,columns=cols)
        output = value_counts(df)
        generator = chain.from_iterable(
            map(
                lambda col: repeat(col, 5), 
                cols))
        vals = np.asarray([
                [
                    1,2,0,1,3,
                    1,2,1,1,2,
                    1,0,2,4,0,
                    0,3,0,3,4,
                    1,0,2,0,4
                ]
            ])
        hier = list(generator)
        filtered = list(compress(hier, vals[0,:]!=1))
        filtered_second_lvl = list(compress([0,1,2,3,4]*5, vals[0,:]))
        filtered_vals = np.asarray([
            list(compress(vals[0,:], vals[0,:]!=1))
        ])
        hindex = [
            filtered,
            filtered_second_lvl
            ]
        expected_output = pd.DataFrame(filtered_vals,
            columns = hindex, index=[""])
        levels = output.columns.levels
        print(output)
        with self.subTest("Index levels"):
            self.assertEqual(len(levels), 2)
        with self.subTest("Value match"):
            self.assertTrue(
                np.allclose(expected_output.values, output.values)
            )
            
    def test_jointly_discard_nan(self):
        r'''
            Test jointly_discard_nan
        '''
        first = np.asarray([
                    [1,2,np.nan,1,3],
                    [1,2,1,1,2,],
                    [1,np.nan,2,4,0],
            ])
        second = np.asarray([
            [1,2,np.nan,1,3],
            [1,2,1,1,2],
            [1,np.nan,2,4,np.nan],
            ])
        third = np.asarray([
            [1,2,np.nan,1,3],
            [1,2,1,1,2],
            [1,0,2,4,0],
            ])
        fourth = np.asarray([
            [1,2,0,1,np.nan],
            [1,2,1,1,2],
            [1,0,2,4,0],
            ])
        fifth= np.asarray([
            [1,2,np.nan,1,3],
            [1,2,1,1,2,],
            [1,7,2,4,0],
            [1,5,2,4,0],
            ])
        sixth = np.asarray([
            [1,2,0,np.nan,3],
            [1,2,1,1,2],
            [1,np.nan,2,4,0],
            [1,0,2,4,0],
            ])
        output1 = jointly_discard_nan(pd.DataFrame(first), 
                                     pd.DataFrame(second),
                                     pd.DataFrame(third)
                                     )
        output2 = jointly_discard_nan(pd.DataFrame(third), 
                                     pd.DataFrame(fourth)
                                     )
        with self.subTest("Single row"):
            self.assertEqual(output1, 
                             pd.Index([1], dtype=np.int64))
        with self.subTest("Two rows"):
            self.assertEqual(list(output2), 
                             [1,2])
        with self.subTest("Test dosctring"):
            docput = jointly_discard_nan(pd.DataFrame(fifth), 
                                     pd.DataFrame(sixth)
                                     )
            docput = [e for e in docput]
            self.assertEqual(docput, [1,3])